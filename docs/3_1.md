# 3주차_ 스프링 시큐리티와 로그인

# 이번 주제

* 다양한 로그인 기법
* JWT란 무엇인가요?
* RefreshToken이란?
* Spring Security란 무엇인가요?

# 발표 내용

## 다양한 로그인 기법

웹 서비스를 제공할 땐 사용자마다 다른 정보를 제공하고 사용할 필요가 있기 때문에 계정과 로그인으로 이를 구별한다. 
로그인 이후, 서버가 사용자(클라이언트)를 구분하기 위해 세션 방식과 Token 방식을 주로 사용한다.
* 세션 방식

세션 방식은 사용자가 로그인 했을 때 서버가 세션과 세션ID를 저장하는 방식을 말한다. 
특정 방법으로 세션ID를 사용자에게 전달하면 사용자는 쿠키에 세션ID를 저장하고 인증이 필요할 때 마다 사용한다.
* Token 방식

Token 방식은 로그인 시 서버는 새로운 access token과 refresh token을 발급하고 사용자에게 전달한다. 
각 http 통신마다 access token은 헤더에 포함되어 인증 수단으로서 작동한다.
* 각 방식의 장단점

각 방식의 차이는 '서버가 인증 수단을 얼마나 관리 하는가' 라고도 볼 수 있다.
* 세션 방식: 서버가 세션에 대한 정보를 저장한다. 인증 정보를 직접 관리 할 수 있어 문제가 생길 시 저장소를 비워 대응할 수 있다. 
세션을 위한 공간이 따로 필요하고 state를 가졌다는 점에서 stateless하지 않고, 서버가 여러 곳 일 경우, 각각 세션을 저장하고 일치시켜야하는 문제가 있다.
* Token 방식: 인증 정보가 필요할 때 인증 수단을 발급한다. 서버가 직접 token을 저장하는 게 아닌 다른 검증 수단을 통해 token을 검사한다. 즉 검증 수단을 갖췄다면 인증을 위한 저장소나 서버를 필요로 하지 않는다.
다른 어플리케이션에서도 인증을 이용할 수 있는 등(OAuth) 확정성이 크다.
하지만 각 통신에서 항상 Token이 포함되어 트래픽에 영향을 끼칠 수 있다. 또 token이 개인 정보를 포함하거나 복호화에 사용될 수 있어 유출 시의 위험이 크다.

## JWT란 무엇인가요?


1. JWT란 무엇인가요?
JWT는 Json Web Token의 약자로 Json 데이터를 서명하기 위해 생성되는 암호화 token이다. 
구성요소는 어떤 알고리즘과 토큰을 사용할 지 담은 header, 암호화된 데이터가 담긴 payload, 암호화의 검증 수단으로 필요한 secret key 3가지 이다.

JWT의 작동 방식은 다음과 같다
* 사용자가 ID와 password로 서버에 로그인 요청
* 로그인 성공시 서버가 access token(+refresh token)을 발급하고 응답에 첨부
* 사용자의 localstorage에 저장하고 요청(request)의 헤더에 token 삽입
* 서버는 token을 검증하고 유효하다면 요청된 정보를 응답 해준다.

2. 다양한 Token 종류

token은 일반적인 token과 claim token으로 나뉜다.

* 일반 token: token으로 무의미한, 무작위의 문자열을 사용한다. 토큰을 만료시킬 수 없고 검증을 위해 DB에 접근할 필요가 있다.
* Claim token: token의 생성에 사용자의 정보가 사용된다. JWT가 대표적이다.
3. Spring에서 JWT를 어떻게 생성할 수 있나요?

Spring에서는 jjwt(io.jsonwebtoken) 라이브러리를 이용해 JWT를 생성할 수 있다.
jsonwebtoken에서는 jwt를 위한 다양한 메소드를 제공하는데 그중 creatToken 메소드로 jwt를 생성한다.
이때 creatToken에 사용자의 정보와 token 만료 시간을 입력한다.
4. JWT의 문제점은 무엇이 있나요?

JWT에 사용자의 정보를 포함시키는 건 장점인 동시에 단점이 될 수 있다. 데이터가 암호화 되어있지만 암호화키가 유출되는 등의 이유로 정보가 노출될 수 있다.
또 만료시간을 정해두는 것 처럼 서버가 직접 token을 만료시키기 어렵다.
## AccessToken, RefreshToken


1. RefreshToken이 탄생한 이유

본래 JWT는 access token만 존재하였다. 하지만 access token은 탈취될 경우 누구나 사용 가능 하다는 문제가 있었다. 
물론 access token의 만료 시간이 짧다면 유출의 문제가 줄어들지만 이렇게 되면 다시 로그인을 통해 token을 발급받아야 하는 것이 문제다.

RefreshToken은 이러한 문제를 보완하기 위한 token이다. refresh token은 access token보다 훨씬 긴 만료 시간을 가지며 access token이 만료될 경우 새로운 access token을 발급받기 위한 인증에 사용된다.
access token을 사용한 통신에서 access token이 만료된 경우 refresh token을 통한 access token의 요청이 이루어진 후 새 access token을 통한 새 요청이 전달된다.
refresh token까지 만료된 이후에는 다시 로그인을 수행하고 access token과 refresh token을 모두 발급받는 것이다.
2. RefreshToken의 구현

access token이 만료되었을 때의 인증 과정을 위해 서버는 발급된 refresh token을 DB에 저장한다. 저장된 refresh token은 몇 주 정도의 긴 만료 시간을 가진다. 만약 사용자가 로그아웃을 요청하면 저장된 refresh token을 삭제, 즉 만료시킨다.
3. RefreshToken의 장단점

refresh token 덕분에 access token은 기간이 짧을 때 생기는 문제가 줄어들게 되었다. 재발급을 위한 인증은 직접 로그인 대신 refresh token이 수행해 사용자의 불편함이 줄었으며 대부분의 통신에 사용되는 access token이 탈취되도 짧은 시간 내에 만료되게 되었다.

하지만 refresh token은 세션 방식과 같이 DB의 저장을 필요로 하기 때문에 결국 저장소도 필요하고 stateless의 측면도 줄어든다. 물론 계속 DB에 접근했던 세션과는 다르게 refresh token은 access token이 만료되었을 때 만 접근 한다는 차이도 있다.

- RTT(Refresh Token Rotation)

하지만 refresh token도 탈취로부터 안전한 것은 아니다. 그렇다면 refresh token도 다시 발급받으면 되지 않을까? 이러한 관점을 이용한 것이 RTR이다.

RTR은 access token을 새로 발급 받을 때 refresh token도 같이 새로 발급 받는 것이다. 이전 refresh token이 유출되었더라도 refresh token이 변경되면서 유출된 token은 만료된 효과를 가지는 것이다.
## Spring Security란 무엇인가요?


1. 인증과 인가란 무엇일까요?

인증이란 사용자가 '누구'인지 확인하는 절차를 말한다. 인가는 사용자가 접근하는 서비스에 올바른 '권한'을 가졌는 지 확인하는 절차를 말한다.

예를 들어 한 평범한 사용자가 웹 서비스에 로그인 했다면 인증에 성공한 것이다. 하지만 인증에 성공했다 해서 관리자 페이지에 접근하고 이용하는 것은 인가되지 않았기 때문에 불가능하다.
정확한 비유는 아닐 수 있지만 서비스에 접근하기 위해 우선 인증하고 인증된 정보를 바탕으로 서비스에 접근해도 되는지 인가를 확인하는 것이라 이해했다.
2. Spring Security의 구조

DispatherServlet에 전달 될 http request의 인증과 인가를 위해 Servlet의 Filter로서 작동하는 것이 Spring Security이다.
요청이 Servlet에 전달되기 까지 여러 filter로 이루어진 filter chain을 거친다. 그 중 DelegatingFilterProxy는 filter chain proxy를 포함하는데 이것이 보안을 위한 filter chain인 security filter chain에 전달한다.

3. Spring Security의 작동 흐름

http request는 우선 AuthenticationFilter를 거친다.
* AuthenticationFilter는 아이디와 비밀번호로 UsernamePasswordAuthenticationToken을 생성한다.
* token은 AuthenticationManager로 전달되고 manager는 AuthenticationProvider로 인증 정보를 조회한다.
* provider가 UserDetailService를 통해서 User DB속 정보를 조회한다.
* 조회 내용이 있다면 UserDetails 객체로 꺼내고 UserDetailService를 거쳐 provider로 전달한다.
* provider는 가진 사용자 정보와 비교하고 인증 완료시 사용자 정보를 포함하는 Authentication 객체를 반환한다.
* Filter까지 Authentication 객체가 반환되면 SecurityContext에 Authentication 객체를 저장하고 끝이 난다.

이는 스프링 시큐리티가 세션-쿠키 방식의 인증을 사용함을 의미한다고 한다.
# 이번 과제


> Spring Security를 프로젝트에 적용해봅니다. 너무 어렵다면 RefreshToken은 하지 않아도 됩니다.