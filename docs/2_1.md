# 2주차_API와 Controller&Service 계층 및 구현

# 이번 주제

* API는 무엇이고 왜 사용할까요?, 또 API를 문서화 하는 방법은 무엇이 있을까요?
* REST API는 무엇일까요? RESTful한 설계는 뭘까요?
* 객체의 직렬화와 역직렬화는 무엇이고 @RequestMapping과 @ModelAttribute의 값 매핑은 어떻게 이뤄지나요?
* Spring Framewrok의 ResponseEntity는 무엇이고 어떻게 활용할 수 있을까요?

# 발표 내용

## API는 무엇이고 왜 사용할까요? 또, API를 문서화 하는 방법은 무엇이 있을까요?


1. API란 무엇인가요?

API(Application Programming Interface)는 애플리케이션간의 통신을 위한 인터페이스이다. 
애플리케이션은 제공하는 서비스에 맞춰 API 프로토콜을 정의하여 다른 애플리케이션과 정보를 주고 받을 수 있다. 클라이언트-서버 구조와 연결해서 API를 제공하는 애플리케이션이 서버, 요청하고 사용하는 애플리케이션이 클라이언트라고 볼 수 있다.

API는 통신 방식 등에 따라 SOAP API, RPC API, REST API로 나뉘지만 현재 웹에서 가장 많이 사용하는 것은 REST API이다.
* SOAP API: XML 형식의 엄격한 프로토콜로 데이터 교환이 이루어진다. 그만큼 보안과 트랜젝션 처리에 강하지만 무겁게 작동한다.
* RPC API: 원격으로 메소드를 호출하는 방식으로 구현되며 기능을 직접 실행시키도록 요청한다. 데이터의 형태는 JSON, XML등 자유롭다.
* REST API: URL을 통한 http 형태의 호출로 통신이 이루어진다. 주로 JSON 형태의 데이터를 교환하며 상대적으로 유연하여 웹에서 자주 사용된다. http 통신에서 CRUD에 대응되는 POST, GET, PUT, DELETE를 사용한다.

2. API 명세서란 무엇인가요?

API를 구현했다면 어떻게 사용해야하는 지 알려줄 필요가 있기 때문에 API 명세서를 사용한다. 즉 API 명세서는 API의 정의가 어떻게 되는지 종류와 기능, 형태 등이 표기된 명세서이다.

REST API를 예시로 들면 API를 사용하기 위한 endpoint와 매개변수, API의 Method(GET, POST 등 어떤 행위인지), 응답의 형태, 인증이 API 명세서에 포함되어야 한다. 각 API의 사용 예시와 오류 처리 형태 또한 표기되면 좋다.

3. API를 명세하기 위해 어떤 도구를 사용할 수 있나요?

API를 명세하기 위한 문서화 도구는 Swagger, spring REST docs, gitbook, postman이 존재한다.
* Swagger: Swagger는 어노테이션을 통해 자동으로 명세서를 생성할 수 있는 도구이다. 오픈 소스로 개발되었으며 자동화로 API 변경사항이 명세서에 바로 적용된다.
* Spring REST docs: 스프링에서 무료로 제공하는 테스트 기반 문서화 도구이다. 세팅이 준비되면 제작된 코드 중 테스트가 통과된 API에 한해 명세서가 생성된다.
* GitBook: git에서 제공하는 유로 문서화 도구로 Markdown을 사용 가능하다. 프로젝트 팀원도 쉽게 작성, 수정할 수 있지만 wiki로서의 기능이 강하다.
* Postman: 정확히는 http REST API를 테스트할 수 있는 도구이며 문서화 기능을 제공하고 있다. API 테스트에 자주 사용되지만 문서화 기능은 상대적으로 부족하다.

## REST API는 뭘까요? RESTful한 설계는 무엇일까요?

REST API는 CRUD 처럼 POST, GET, PUT, DELETE, PATCH로 API를 구분짓고 사용하고 있다. RESTful한 설계란 이러한 REST의 특징이 잘 지켜진 설계를 말한다. REST API의 특징들은 다음과 같다.
* Stateless: 서버가 클라이언트의 상태를 직접 저장해선 안되며 필요하다면 API 통신에 포함되어야 한다.
* 메소드를 구분: 메소드가 용도에 따라 명확히 구분되어야 한다. 즉 GET 통신으로 데이터 새롭게 생성하거나 삭제해선 안된다.
* 계층형 구조: URL에서는 /형태로 구분되는 것을 확인할 수 있다. 이처럼 각 자원은 구분, 분리되어 사용된다.

이 외에도 REST 구조가 가지는 여러가지 조건을 잘 갖추어야 RESTful한 설계라고 할 수 있다.


## 객체의 직렬화와 역직렬화는 무엇이고 **@RequestBody**과 @ModelAttribute의 값 매핑은 어떻게 이뤄지나요?

자바의 객체는 당연하게도 JSON 등의 일반적인 데이터 형태와는 다르기 때문에 중간의 변환과정이 필요하다. 직렬화는 JSON, XML 등을 객체로 변환하는 것이며 역직렬화는 반대로 객체를 교환할 수 있는 데이터 형태로 변환하는 것이다.
REST API의 요청으로 JSON이 전달되면 코드에서 처리하기 위해 역직렬화가 먼저 이루어지고, 처리된 결과를 응답에 포함시키기 위해 데이터를 직렬화한다.

1. Controller의 메소드 내 아무런 어노테이션이 없을 때 스프링은 이 값들을 어떻게 처리하나요?

@RequestBody와 @ModelAttribute는 이러한 데이터 변환과 관련된 어노테이션이다. 만약 Controller의 메소드 내에 어노테이션이 없다면 메소드에 사용되는 파라미터의 형식에 따라 어노테이션이 자동으로 할당된다.
String, Integer과 같은 간단한 파라미터일 경우 @RequestBody가, 보다 복잡한 파라미터가 포함된 경우 @ModelAttribute가 알맞게 적용되어 데이터를 변환한다.

2. 스프링에서 객체의 직렬화와 역직렬화는 어떻게 이뤄질까요?

   1. ObjectMapper의 작동방식

   Jackson의 ObjectMapper는 JSON의 각 필드의 이름과 getter와 setter을 맞춰서 사용한다. 예를 들어 getItem이라는 getter가 있다면 앞의 'get'을 제거하고 앞의 대문자를 소문자로 바꿔 item 필드에 연결해서 변환한다.

   그런데 getter, setter의 이름이 필드와 관련 없는 것이라면 예상치 못한 데이터가 JSON에 포함될 수 있다. 이 경우 메소드에 @JsonIgnore를 포함시켜 ObjectMapper의 작동 대상에서 제외시킬 수 있다.

   2. @RequestBody와 @ModelAttribute는 어떤 차이가 있을까요?

   @RequestBody은 데이터를 오브젝트로 변환하고 @ModelAttribute는 객체에 매핑한다.

   * @RequestBody: 데이터를 HttpMessageConverter로 파싱하고 Java 객체로 변환한다. 필드에 바인드할 생성자나 setter가 필요없지만 직렬화를 위한 기본 생성자가 반드시 있어야 한다.
   * @ModelAttribute: http 파라미터 데이터를 Java 객체에 매핑한다. 따라서 필드에 바인딩을 위한 생성자나 setter가 필요하다. 단 데이터가 query string이나 form 형태일 필요가 있다.


## Spring Framework의 ResponseEntity는 무엇이고 어떻게 활용할 수 있을까요?


1. 요청과 응답이란 무엇일까요?

REST API를 고려하면 요청은 서비스를 이용하고자 요구하는 메시지이고 응답은 반대로 이용한 것에 대한 메시지이다. 요청이 들어왔을 때 원하는 데이터나 요청하는 사용자 등 비지니스 로직을 처리하기 위한 정보들이 포함되는 경우가 많다.

2. 응답에는 무슨 값이 담길 수 있을까요?

그렇다면 응답에는 어떤 값이 포함될까? 가장 대표적인 건 처리에 대한 결과이다. 특히 GET 통신은 데이터를 요구하는 통신이기에 필요로하는 데이터가 응답에 포함된다. 
직접적인 데이터가 아니더라도 통신이 정상적으로 수행되었는지, 수행되었다면 결과가 어떤지, 실패했다면 어떤 문제가 발생했는지 클라이언트에게 알려줄 필요가 있다. 클라이언트가 통신에 대해 알아야 할 여러 결과가 응답에 담겨 전달되는 것이다.
3. 왜 ResponseEntity를 사용하면 좋을까요?

즉 ResponseEntity는 응답(Response)을 위해 HttpEntity를 상속받아 구현한 Entity이다. 동일하게 Request를 위한 RequestEntity도 존재한다.

HttpEntity를 상속받았기 때문에 ResponseEntity는 HttpStatus, HttpHeaders, HttpBody를 포함한다. 즉 자동으로 Spring이 생성해주는 것보다 서 세밀하게 status, headers, body의 값을 조정하여 응답할 수 있다. 또 각각을 직접 다루면서 테스트도 명확해지고 RESTful한 설계를 적용하기도 좋다.

# 이번 과제

> Controller와 Service를 구성하는 시간을 가져봅니다.

# 같이 고민해봐요


> @ModelAttribute와 @RequestBody는 어떨 때 이용하는 걸까요? @PathVariable @RequestParam은 무슨 차이일까요? 어떻게 해야 RESTful한 API를 만들 수 있을까요? 명세서는 어떻게 만들어야 할까요? Postman과 Swagger는 어떤 장단점이 있을까요? 또, Springdoc과 Springfox는 무슨 차이일까요? DTO는 어떻게 설계하는 것이 좋을까요?